#include <iostream>
#include <filesystem>
#include <fstream>
#include <vector>
#include <string>
#include <chrono>
#include <format>
#include <map>

void writeToFile(std::ostream& stream, const std::filesystem::path& input_path);

std::filesystem::path input_path;
int main(int argc, char** argv)
{
    if(argc < 3){
        std::cerr << "Usage: ResourceLoader <resources-path> <output-path>" << std::endl;
        return 1;
    }

    input_path = std::filesystem::path(argv[1]);
    auto output_path = std::filesystem::path(argv[2]);
    std::ofstream output_file = std::ofstream(output_path.append("Resources.build.hpp"), std::ios::out);

    writeToFile(output_file, input_path);
    return 0;
}


std::vector<std::string> getFilesInDirectory(const std::filesystem::path& directory)
{
    std::vector<std::string> files;
    for (const auto& entry : std::filesystem::directory_iterator(directory))
    {
        if(entry.is_directory()){
            auto directoryFiles = getFilesInDirectory(entry.path().string());
            files.insert(files.end(), directoryFiles.begin(), directoryFiles.end());
        } else if(entry.is_regular_file() && entry.path().extension() != ".gitkeep"){
            files.push_back(entry.path().string());
        }
    }
    return files;
}

void writeTop(std::ostream& stream, const std::filesystem::path& input_path)
{
    constexpr auto code = R"(
// This file is generated by ResourceLoader, do not edit it manually
// Generated from {}
// Generated on {}

#pragma once

#include <stdexcept>
#include <string>
#include <fstream>
#include <sstream>
#include <memory>

#include <SFML/Graphics/Texture.hpp>
#include <SFML/Audio/SoundBuffer.hpp>
#include <SFML/Audio/Music.hpp>

namespace Resources {{
    inline std::unique_ptr<sf::Music> make_music(const std::string& path);
    inline std::string read_text(const std::string& path);
    inline sf::Texture make_texture(const std::string& path);
    inline sf::SoundBuffer make_soundBuffer(const std::string& path);

)";

    const std::string time = std::format("{:%Y-%m-%d %H:%M}", std::chrono::system_clock::now());
    stream << std::format(code, input_path.string(), time);
}

void writeBottom(std::ostream& stream)
{
    constexpr auto code = R"(
    inline std::unique_ptr<sf::Music> make_music(const std::string& path)
    {{
        auto music = std::make_unique<sf::Music>();
        if(!music->openFromFile(path))
            throw std::runtime_error("Failed to load music " + path);
        return music;
    }}

    inline std::string read_text(const std::string& path)
    {{
        std::stringstream buffer;

        std::ifstream file(path, std::ios::in);
        if(!file.is_open())
            throw std::runtime_error("Could not open file " + path);

        buffer << file.rdbuf();
        return buffer.str();
    }}

    inline sf::Texture make_texture(const std::string& path)
    {{
        sf::Texture texture;
        if(!texture.loadFromFile(path))
            throw std::runtime_error("Failed to load texture " + path);
        return texture;
    }}

    inline sf::SoundBuffer make_soundBuffer(const std::string& path)
    {{
        sf::SoundBuffer buffer;
        if(!buffer.loadFromFile(path))
            throw std::runtime_error("Failed to load sound " + path);
        return buffer;
    }}

}} // namespace Resources
)";

    stream << std::format(code);
}

struct ResourceLeaf {
    std::string declaration;
    std::string definition;

    static ResourceLeaf make(const std::string_view path)
    {
        ResourceLeaf leaf;
        const auto it = std::find_if(string_constants.begin(), string_constants.end(), [&path](const auto& prefix){
            return path.substr(0, path.find_first_of('/')) == prefix.first;
        });
        const auto [type, fun] = it->second;

        const std::string_view name = path.substr(path.find_last_of('/') + 1, path.find_first_of('.') - path.find_last_of('/') - 1);

        leaf.declaration = std::format("{} {} =", type, name);
        leaf.definition = std::format("{}(\"{}/{}\");", fun, input_path.string(), path);

        return leaf;
    }

    private:
        constexpr static std::array<std::pair<std::string_view, std::pair<std::string_view, std::string_view>>, 4> string_constants {
            std::make_pair("music",
                std::make_pair("const std::unique_ptr<sf::Music>","make_music")),
            std::make_pair("text", 
                std::make_pair("const std::string","read_text")),
            std::make_pair("textures", 
                std::make_pair("const sf::Texture","make_texture")),
            std::make_pair("sounds", 
                std::make_pair("const sf::SoundBuffer","make_soundBuffer")),
        };
};

struct ResourceNode {
    int depth{0};
    std::map<std::string_view, ResourceNode> children{};
    std::map<std::string_view, ResourceLeaf> leaves{};

    ResourceNode& operator+=(const std::string_view path)
    {
        size_t pos = 0;
        for(int d = 0; d < depth; d++)
            pos = path.find_first_of('/', pos + 1) + 1;
        size_t nextPos = path.find_first_of('/', pos + 1);

        if(nextPos == std::string_view::npos){
            leaves[path.substr(pos + 1)] = ResourceLeaf::make(path);
        } else {
            std::string_view name = path.substr(pos, nextPos - pos);

            if(children.find(name) == children.end())
                children[name] = ResourceNode{depth + 1};
            children[name] += path;
        }

        return *this;
    }
};

std::ostream& operator<<(std::ostream& stream, const ResourceNode& node)
{
    const int tabulation = node.depth + 1;
    for(const auto& [name, leaf] : node.leaves){
        stream << std::string(tabulation, '\t') << leaf.declaration << std::endl;
        stream << std::string(tabulation + 1, '\t') << leaf.definition << std::endl;
    }

    for(const auto& [name, child] : node.children){
        stream << std::string(tabulation, '\t') << "namespace " << name << " {" << std::endl;
        stream << child;
        stream << std::string(tabulation, '\t') << "}" << std::endl;
    }
    return stream;
}

void writeToFile(std::ostream& stream, const std::filesystem::path& input_path){
    writeTop(stream, input_path);

    constexpr std::array<std::string_view, 4> resourceTypes {
        "music",
        "text",
        "textures",
        "sounds",
    };

    const std::vector<std::string> files = getFilesInDirectory(input_path.string());
    for (const auto& type : resourceTypes) {
        ResourceNode root;

        for (const auto& file : files) {
            const std::string_view relativePath = std::string_view(file).substr(input_path.string().size() + 1);
            if(relativePath.substr(0, relativePath.find_first_of('/')) == type){
                root += relativePath;
            }
        }
        if(root.children.empty() && root.leaves.empty())
            continue;

        auto [name, node] = *root.children.begin();
        stream << root;
    }

    writeBottom(stream);
}