#include <iostream>
#include <filesystem>
#include <fstream>
#include <vector>
#include <array>
#include <string>
#include <sstream>
#include <chrono>
#include <format>
#include <map>

#ifdef _WIN32
    #define SLASH "\\"
#else
    #define SLASH "/"
#endif

void writeToFile(const std::filesystem::path& output_path, const std::filesystem::path& input_path);

int main(int argc, char** argv)
{
    if(argc < 3){
        std::cerr << "Usage: ResourceLoader <resources-path> <output-path>" << std::endl;
        return 1;
    }

    std::filesystem::path input_path = std::filesystem::path(argv[1]);
    std::filesystem::path output_path = std::filesystem::path(argv[2]);
    
    writeToFile(output_path, input_path);
    return 0;
}


std::vector<std::string> getFilesInDirectory(const std::filesystem::path& directory)
{
    std::vector<std::string> files;
    for (const auto& entry : std::filesystem::directory_iterator(directory))
    {
        if(entry.is_directory()){
            auto directoryFiles = getFilesInDirectory(entry.path().string());
            files.insert(files.end(), directoryFiles.begin(), directoryFiles.end());
        } else if(entry.is_regular_file() && entry.path().extension() != ".gitkeep"){
            files.push_back(entry.path().string());
        }
    }
    return files;
}

void writeTop(std::ostream& header_stream, std::ostream& source_stream, const std::filesystem::path& input_path)
{
    constexpr auto header_code = R"(
// This file is generated by ResourceLoader, do not edit it manually
// Generated from {}
// Generated on {}

#pragma once

#include <string>
#include <memory>

#include <SFML/Graphics/Texture.hpp>
#include <SFML/Audio/SoundBuffer.hpp>
#include <SFML/Audio/Music.hpp>

namespace Resources {{
)";

    constexpr auto source_code = R"(
// This file is generated by ResourceLoader, do not edit it manually
// Generated from {}
// Generated on {}

#include <Resources.build.hpp>

#include <fstream>
#include <stdexcept>
#include <sstream>

namespace Resources {{
    inline std::unique_ptr<sf::Music> make_music(const std::string& path);
    inline std::string read_text(const std::string& path);
    inline sf::Texture make_texture(const std::string& path);
    inline sf::SoundBuffer make_soundBuffer(const std::string& path);
)";

    const std::string time = std::format("{:%Y-%m-%d %H:%M}", std::chrono::system_clock::now());
    header_stream << std::format(header_code, input_path.string(), time);
    source_stream << std::format(source_code, input_path.string(), time);
}

void writeBottom(std::ostream& header_stream, std::ostream& source_stream)
{
    constexpr auto header_code = R"(
}} // namespace Resources
)";
    constexpr auto source_code = R"(
    inline std::unique_ptr<sf::Music> make_music(const std::string& path)
    {{
        auto music = std::make_unique<sf::Music>();
        if(!music->openFromFile(path))
            throw std::runtime_error("Failed to load music " + path);
        return music;
    }}

    inline std::string read_text(const std::string& path)
    {{
        std::stringstream buffer;

        std::ifstream file(path, std::ios::in);
        if(!file.is_open())
            throw std::runtime_error("Could not open file " + path);

        buffer << file.rdbuf();
        return buffer.str();
    }}

    inline sf::Texture make_texture(const std::string& path)
    {{
        sf::Texture texture;
        if(!texture.loadFromFile(path))
            throw std::runtime_error("Failed to load texture " + path);
        return texture;
    }}

    inline sf::SoundBuffer make_soundBuffer(const std::string& path)
    {{
        sf::SoundBuffer buffer;
        if(!buffer.loadFromFile(path))
            throw std::runtime_error("Failed to load sound " + path);
        return buffer;
    }}

}} // namespace Resources
)";

    header_stream << std::format(header_code);
    source_stream << std::format(source_code);
}

struct ResourceLeaf {
    std::string declaration;
    std::string definition;

    static ResourceLeaf make(const std::string_view path)
    {
        ResourceLeaf leaf;
        const auto it = std::find_if(string_constants.begin(), string_constants.end(), [&path](const auto& prefix){
            return path.substr(0, path.find_first_of(SLASH)) == prefix.first;
        });
        const auto [type, fun] = it->second;

        const std::string_view name = path.substr(path.find_last_of(SLASH) + 1, path.find_first_of('.') - path.find_last_of(SLASH) - 1);
        const auto relative_path = std::filesystem::path("resources") / path;

        auto relative_path_str = relative_path.string();

        #ifdef _WIN32
        const auto copy_str = relative_path_str;
        relative_path_str.clear();

        relative_path_str += "..\\\\";

        for (const char c : copy_str)
            if (c == '\\')
                relative_path_str += "\\\\";
            else
                relative_path_str += c;
        #endif

        leaf.declaration = std::format("extern {} {}", type, name);
        leaf.definition = std::format("{} {} = {}(\"{}\")",
            type, name, fun, relative_path_str);

        return leaf;
    }

    private:
        constexpr static std::array<std::pair<std::string_view, std::pair<std::string_view, std::string_view>>, 4> string_constants {
            std::make_pair("music",
                std::make_pair("const std::unique_ptr<sf::Music>","make_music")),
            std::make_pair("text", 
                std::make_pair("const std::string","read_text")),
            std::make_pair("textures", 
                std::make_pair("const sf::Texture","make_texture")),
            std::make_pair("sounds", 
                std::make_pair("const sf::SoundBuffer","make_soundBuffer")),
        };
};

struct ResourceNode {
    int depth{0};
    std::map<std::string_view, ResourceNode> children{};
    std::map<std::string_view, ResourceLeaf> leaves{};

    ResourceNode& operator+=(const std::string_view path)
    {
        size_t pos = 0;
        for(int d = 0; d < depth; d++)
            pos = path.find_first_of(SLASH, pos + 1) + 1;
        size_t nextPos = path.find_first_of(SLASH, pos + 1);

        if(nextPos == std::string_view::npos){
            leaves[path.substr(pos + 1)] = ResourceLeaf::make(path);
        } else {
            std::string_view name = path.substr(pos, nextPos - pos);

            if(children.find(name) == children.end())
                children[name] = ResourceNode{depth + 1};
            children[name] += path;
        }

        return *this;
    }

    std::string header_part() const {
        const int tabulation = depth + 1;
        
        std::stringstream stream;

        for (const auto& [name, leaf] : leaves){
            stream << std::string(tabulation, '\t') << leaf.declaration << ";" << std::endl;
        }

        for (const auto& [name, child] : children){
            stream << std::string(tabulation, '\t') << "namespace " << name << " {" << std::endl;
            stream << child.header_part();
            stream << std::string(tabulation, '\t') << "};" << std::endl;
        }

        return stream.str();
    }

    std::string source_part() const {
        const int tabulation = depth + 1;
        
        std::stringstream stream;

        for (const auto& [name, leaf] : leaves){
            stream << std::string(tabulation, '\t') << leaf.definition << ";" << std::endl;
        }

        for (const auto& [name, child] : children){
            stream << std::string(tabulation, '\t') << "namespace " << name << " {" << std::endl;
            stream << child.source_part();
            stream << std::string(tabulation, '\t') << "};" << std::endl;
        }

        return stream.str();
    }
};

void writeToFile(const std::filesystem::path& output_path, const std::filesystem::path& input_path){
    auto header_path = output_path;
    header_path.append("inc").append("Resources.build.hpp");

    auto source_path = output_path;
    source_path.append("src").append("Resources.build.cpp");

    std::ofstream header_stream = std::ofstream(header_path, std::ios::out);
    std::ofstream source_stream = std::ofstream(source_path, std::ios::out);

    writeTop(header_stream, source_stream, input_path);

    constexpr std::array<std::string_view, 4> resourceTypes {
        "music",
        "text",
        "textures",
        "sounds",
    };

    const std::vector<std::string> files = getFilesInDirectory(input_path.string());
    for (const auto& type : resourceTypes) {
        ResourceNode root;

        for (const auto& file : files) {
            const std::string_view relativePath = std::string_view(file).substr(input_path.string().size() + 1);
            if(relativePath.substr(0, relativePath.find_first_of(SLASH)) == type){
                root += relativePath;
            }
        }
        if(root.children.empty() && root.leaves.empty())
            continue;

        header_stream << root.header_part();
        source_stream << root.source_part();
    }

    writeBottom(header_stream, source_stream);
}